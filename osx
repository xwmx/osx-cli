#!/usr/bin/env bash
#
#                        _ _
#   ___  _____  __   ___| (_)
#  / _ \/ __\ \/ /  / __| | |
# | (_) \__ \>  <  | (__| | |
#  \___/|___/_/\_\  \___|_|_|
#
# Shortcuts for OS X operations.
#
# Copyright (c) 2015 William Melody â€¢Â hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

# Treat unset variables and parameters other than the special parameters â€˜@â€™ or
# â€˜*â€™ as an error when performing parameter expansion. An 'unbound variable'
# error message will be written to the standard error, and a non-interactive
# shell will exit.
#
# This requires using parameter expansion to test for unset variables.
#
# http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
#
# The two approaches that are probably the most appropriate are:
#
# ${parameter:-word}
#   If parameter is unset or null, the expansion of word is substituted.
#   Otherwise, the value of parameter is substituted. In other words, "word"
#   acts as a default value when the value of "$parameter" is blank. If "word"
#   is not present, then the default is blank (essentially an empty string).
#
# ${parameter:?word}
#   If parameter is null or unset, the expansion of word (or a message to that
#   effect if word is not present) is written to the standard error and the
#   shell, if it is not interactive, exits. Otherwise, the value of parameter
#   is substituted.
#
# Examples
# ========
#
# Arrays:
#
#   ${some_array[@]:-}              # blank default value
#   ${some_array[*]:-}              # blank default value
#   ${some_array[0]:-}              # blank default value
#   ${some_array[0]:-default_value} # default value: the string 'default_value'
#
# Positional variables:
#
#   ${1:-alternative} # default value: the string 'alternative'
#   ${2:-}            # blank default value
#
# With an error message:
#
#   ${1:?'error message'}  # exit with 'error message' if variable is unbound
#
# Short form: set -u
set -o nounset


# Exit immediately if a pipeline returns non-zero.
#
# NOTE: this has issues. When using read -rd '' with a heredoc, the exit
# status is non-zero, even though there isn't an error, and this setting
# then causes the script to exit. read -rd '' is synonymous to read -d $'\0',
# which means read until it finds a NUL byte, but it reaches the EOF (end of
# heredoc) without finding one and exits with a 1 status. Therefore, when
# reading from heredocs with set -e, there are three potential solutions:
#
# Solution 1. set +e / set -e again:
#
# set +e
# read -rd '' variable <<EOF
# EOF
# set -e
#
# Solution 2. <<EOF || true:
#
# read -rd '' variable <<EOF || true
# EOF
#
# Solution 3. Don't use set -e or set -o errexit at all.
#
# More information:
#
# https://www.mail-archive.com/bug-bash@gnu.org/msg12170.html
#
# Short form: set -e
set -o errexit

# Return value of a pipeline is the value of the last (rightmost) command to
# exit with a non-zero status, or zero if all commands in the pipeline exit
# successfully.
set -o pipefail

# Set IFS to just newline and tab at the start
#
# http://www.dwheeler.com/essays/filenames-in-shell.html
#
# $DEFAULT_IFS and $SAFER_IFS
#
# $DEFAULT_IFS contains the default $IFS value in case it's needed, such as
# when expanding an array and you want to separate elements by spaces.
# $SAFER_IFS contains the preferred settings for the program, and setting it
# separately makes it easier to switch between the two if needed.
#
# NOTE: also printing $DEFAULT_IFS to /dev/null to avoid shellcheck warnings
# about the variable being unused.
DEFAULT_IFS="$IFS"; printf "%s" "$DEFAULT_IFS" > /dev/null
SAFER_IFS="$(printf '\n\t')"
# Then set $IFS
IFS="$SAFER_IFS"

###############################################################################
# Globals
###############################################################################

_VERSION="0.1.0-alpha"

# DEFAULT_COMMAND
#
# The command to be run by default, when no command name is specified. If the
# environment has an existing $DEFAULT_COMMAND set, then that value is used.
DEFAULT_COMMAND="${DEFAULT_COMMAND:-help}"

###############################################################################
# Debug
###############################################################################

# _debug()
#
# A simple function for executing a specified command if the `_use_debug`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
_debug() {
  if [[ "${_use_debug:-"0"}" -eq 1 ]]; then
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  "
    "$@"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n"
  fi
}
# debug()
#
# Print the specified message if the `_use_debug` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
#
# Usage:
#   debug "Debug info. Variable: $0"
debug() {
  _debug echo "$@"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "âŒ  "
  "$@" 1>&2
  exit 1
}
# die()
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
#
# Usage:
#   die "Error message. Variable: $0"
die() {
  _die echo "$@"
}

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
raw_options="$*"

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
#
# In this example, `-x` and `-h` are regular short options, while `o` is
# assumed to have an argument and will be split if joined with the string,
# meaning `-oARG` would be split to `-o ARG`.
optstring=h

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while (($#)); do
  case $1 in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++)); do
        # extract 1 character from position 'i'
        c=${1:i:1}
        # add current char to options
        options+=("-$c")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*) options+=("${1%%=*}" "${1#*=}");;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("$@")
      break
      ;;
    # otherwise, nothing special
    *) options+=("$1");;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize command_argv array
#
# This array contains all of the arguments that get passed along to each
# command. This is essentially the same as the program arguments, minus those
# that have been filtered out in the program option parsing loop. This array
# is initialized with $0, which is the program's name.
command_argv=("$0")
# Initialize $cmd and $_use_debug, which can continue to be blank depending on
# what the program needs.
cmd=""
_use_debug=0

while [ $# -gt 0 ]; do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      cmd="help"
      ;;
    --version)
      cmd="version"
      ;;
    --debug)
      _use_debug=1
      ;;
    *)
      # The first non-option argument is assumed to be the command name.
      # All subsequent arguments are added to $command_arguments.
      if [[ -n $cmd ]]; then
        command_argv+=("$opt")
      else
        cmd="$opt"
      fi
      ;;
  esac
done

# Set $command_parameters to $command_argv, minus the initial element, $0. This
# provides an array that is equivalent to $* and $@ within each command
# function, though the array is zero-indexed, which could lead to confusion.
command_parameters=("${command_argv[@]:1}")

_debug printf "\$cmd: %s\n" "$cmd"
_debug printf "\$raw_options (one per line):\n%s\n" "$raw_options"
_debug printf "\$command_argv: %s\n" "${command_argv[*]}"
_debug printf "\$command_parameters: %s\n" "${command_parameters[*]:-}"

###############################################################################
# Environment
###############################################################################

# $_ME
#
# Set to the program's basename.
_ME=$(basename "$0")

_debug printf "\$_ME: %s\n" "$_ME"

###############################################################################
# Load Commands
###############################################################################

# Initialize defined_commands array.
defined_commands=()

# _load_commands()
#
# Loads all of the commands sourced in the environment.
#
# Usage:
#   _load_commands
_load_commands() {

  _debug printf "_load_commands(): entering...\n"
  _debug printf "_load_commands() declare -F:\n%s\n" "$(declare -F)"

  # declare is a bash built-in shell function that, when called with the '-F'
  # option, displays all of the functions with the format
  # `declare -f function_name`. These are then assigned as elements in the
  # $function_list array.
  local function_list=($(declare -F))

  for c in "${function_list[@]}"
  do
    # Each element has the format `declare -f function_name`, so set the name
    # to only the 'function_name' part of the string.
    local function_name
    function_name=$(printf "%s" "$c" | awk '{ print $3 }')

    _debug printf "_load_commands() \$function_name: %s\n" "$function_name"

    # Add the function name to the $defined_commands array unless it starts
    # with an underscore or is one of the desc(), debug(), or die() functions,
    # since these are treated as having 'private' visibility.
    if ! ( [[ "$function_name" =~ ^_(.*)  ]] || \
           [[ "$function_name" == "desc"  ]] || \
           [[ "$function_name" == "debug" ]] || \
           [[ "$function_name" == "die"   ]]
    ); then
      defined_commands+=("$function_name")
    fi
  done

  _debug printf \
    "commands() \$defined_commands:\n%s\n" \
    "${defined_commands[*]:-}"
}

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_main() {
  _debug printf "main(): entering...\n"
  _debug printf "main() \$cmd (upon entering): %s\n" "$cmd"

  # If $cmd is blank, then set to help
  if [[ -z $cmd ]]; then
    cmd="$DEFAULT_COMMAND"
  fi

  # Load all of the commands.
  _load_commands

  # If the command is defined, run it, otherwise return an error.
  if ( _contains "$cmd" "${defined_commands[*]:-}" ); then
    # Pass all comment arguments to the program except for the first ($0).
    $cmd "${command_parameters[@]:-}"
  else
    _die printf "Unknown command: %s\n" "$cmd"
  fi
}

###############################################################################
# Utility Functions
###############################################################################

# _function_exists()
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _contains()
#
# Takes an item and a list and determines whether the list contains the item.
#
# Usage:
#   _contains "$item" "${list[*]}"
_contains() {
  local test_list=(${*:2})
  for _test_element in "${test_list[@]:-}"
  do
    _debug printf "_contains() \$_test_element: %s\n" "$_test_element"
    if [[ "$_test_element" == "$1" ]]; then
      _debug printf "_contains() match: %s\n" "$1"
      return 0
    fi
  done
  return 1
}

# _join()
#
# Takes a separator and a list of items, joining that list of items with the
# separator.
#
# Usage:
#   _join "," a b c
#   _join "${an_array[@]}"
_join() {
  local separator
  local target_array
  local dirty
  local clean
  separator="$1"
  target_array=(${@:2})
  dirty="$(printf "${separator}%s"  "${target_array[@]}")"
  clean="${dirty:${#separator}}"
  printf "%s" "${clean}"
}

# _command_argv_includes()
#
# Takes a possible command argument and determines whether it is included in
# the command argument list.
#
# This is a shortcut for simple cases where a command wants to check for the
# presence of options quickly without parsing the options again.
#
# Usage:
#   _command_argv_includes "an_argument"
_command_argv_includes() {
  _contains "$1" "${command_argv[*]}"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'EOM'
# some message
# EOM
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z $1 ]] && _die printf "desc: No command name specified.\n"
  if [[ -n ${2:-} ]]; then
    read -d '' "_desc_$1" <<EOM
$2
EOM
    _debug printf "desc() set with argument: _desc_%s\n" "$1"
  else
    read -d '' "_desc_$1"
    _debug printf "desc() set with pipe: _desc_%s\n" "$1"
  fi
  set -e
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  local var="_desc_$1"
  if [[ -n ${!var:-} ]]; then
    printf "%s\n" "${!var}"
  else
    printf "No additional information for \`%s\`\n" "$1"
  fi
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc version <<EOM
Usage:
  $_ME ( version | --version )

Description:
  Display the current program version.

  To save you the trouble, the current version is $_VERSION
EOM
version() {
  printf "%s\n" "$_VERSION"
}

# Help ########################################################################

desc help <<EOM
Usage:
  $_ME help [<command>]

Description:
  Display help information for $_ME or a specified command.
EOM
help() {
  if [[ ${#command_argv[@]} = 1 ]]; then
    cat <<EOM
                       _ _
  ___  _____  __   ___| (_)
 / _ \\/ __\\ \\/ /  / __| | |
| (_) \\__ \\>  <  | (__| | |
 \\___/|___/_/\\_\\  \\___|_|_|

Shortcuts for OS X operations.

Version: $_VERSION

Usage:
  $_ME <command> [--command-options] [<arguments>]
  $_ME -h | --help
  $_ME --version

Help:
  $_ME help [<command>]

$(commands)
EOM
  else
    _print_desc "$1"
  fi
}

# Command List ################################################################

desc commands <<EOM
Usage:
  $_ME commands [--raw]

Options:
  --raw  Display the command list without formatting.

Description:
  Display the list of available commands.
EOM
commands() {
  if _command_argv_includes "--raw"; then
    printf "%s\n" "${defined_commands[@]}"
  else
    printf "Available commands:\n"
    printf "  %s\n" "${defined_commands[@]}"
  fi
}

###############################################################################
# Commands
# ========.....................................................................
#
# Example command group structure:
#
# desc example ""   - Optional. A short description for the command.
# example() { : }   - The command called by the user.
#
#
# desc example <<EOM
#   Example help text. Options specified with http://docopt.org/
# EOM
# example() {
#   echo "Hello, World!"
# }
#
###############################################################################

# --------------------------------------------------------------------- Airport

desc apinfo <<EOM
Usage:
  $_ME apinfo

Description:
  Show the current airport status.
EOM
apinfo() {
  /System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport --getinfo
}

# ----------------------------------------------------------------------- Audio

desc play <<EOM
Alias for \`afplay\`
$(printf "%s\n" "$(afplay -h 2>&1)" | sed s/afplay/"$_ME"\ play/g)
EOM
play() {
  afplay "$*"
}

desc volume <<EOM
Usage:
  $_ME volume (  <0-9> | <00-100> | mute | unmute )

Arguments:
  <none>    Print the current output volume level as a percent.
  <0-9>     Set the output volume to about the nearest tenth percent. Sometimes
            the actual number is slightly off for reasons unknown.
  <00-100>  Set the output volume to the specified percent.
  mute      Mute output.
  unmute    Unmute output.
EOM
_print_mute_state() {
  local _mute_state
  _mute_state=$(osascript -e "output muted of (get volume settings)")
  printf "Mute: %s\n" "${_mute_state}"
}
_print_current_output_volume() {
  local _volume
  _volume=$(osascript -e "output volume of (get volume settings)")
  printf "Output volume: %s%%\n" "${_volume}"
}
volume() {
  case "${1}" in
    mute)
      osascript -e "set volume output muted true"
      _print_mute_state
      ;;
    unmute)
      osascript -e "set volume output muted false"
      _print_mute_state
      ;;
    *[0-9][0-9])
      osascript -e "set volume output volume ${1}"
      _print_current_output_volume
      ;;
    [0-9])
      osascript -e "set volume output volume ${1}0"
      _print_current_output_volume
      ;;
    *)
      _print_current_output_volume
      _print_mute_state
      ;;
  esac

}

# --------------------------------------------------------------------- battery

desc battery <<EOM
Usage:
  $_ME battery [-l|--long]

Options:
  -l --long  Print longform information about the battery status.

Description:
  Print the current battery status.
EOM
battery() {
  local _long_status=
  for arg in "${command_argv[@]:-}"; do
    case $arg in
      -l|--long)
        _long_status=1
        ;;
      *)
        arguments+=($arg)
        ;;
    esac
  done

  if [[ -n "$_long_status" ]]; then
    ioreg -l -n AppleSmartBattery -r
  else
    pmset -g batt
  fi
}

# ------------------------------------------------------------------------- DNS

desc flushdns <<EOM
Usage:
  $_ME flushdns

Description:
  Flush Directory Service cache.
EOM
flushdns() {
  # pre-yosemite
  # need os x version checking to use properly
  #dscacheutil -flushcache && killall -HUP mDNSResponder
  sudo discoveryutil mdnsflushcache && sudo discoveryutil udnsflushcaches
}

# ---------------------------------------------------------------------- Finder

desc clean_ds_store <<EOM
Usage:
  $_ME clean_ds_store

Description:
  Recursively delete \`.DS_Store\` files
EOM
clean_ds_store() {
  find . -type f -name '*.DS_Store' -ls -delete
}

desc desktop <<EOM
Usage:
  $_ME desktop ( hide | show )

Description:
  Hide/show all desktop icons (useful when presenting).
EOM
desktop() {
  _arg=$(_get_command_argument 1)
  case "$_arg" in
    hide)
      defaults write com.apple.finder CreateDesktop -bool false && \
        killall Finder
      ;;
    show)
      defaults write com.apple.finder CreateDesktop -bool true && \
        killall Finder
      ;;
    *)
      _print_desc "desktop"
      ;;
  esac
}

desc finder <<EOM
Usage:
  $_ME finder hidden ( hide | show )

Description:
  Hide/show hidden files in the Finder.
EOM
finder() {
  _target="$1"
  _action="$2"
  if [[ "$_target" != "hidden" ]]; then
    _print_desc "finder"
    exit 1
  fi
  case "$_action" in
    hide)
      defaults write com.apple.finder AppleShowAllFiles -bool false && \
        killall Finder
      ;;
    show)
      defaults write com.apple.finder AppleShowAllFiles -bool true && \
        killall Finder
      ;;
    *)
      _print_desc "finder"
      ;;
  esac
}

# --------------------------------------------------------------------- hdiutil

desc eject <<EOM
Usage:
  $_ME eject <volname>

Description:
  Ejects a given volume (eg, a disk image).
EOM
eject() {
  if [[ -z "$1" ]]; then
    _die _print_desc "eject"
  fi
  hdiutil eject "/Volumes/$*"
}

# ------------------------------------------------------------------ JavaScript

desc jsc <<EOM
Usage:
  $_ME jsc [<filename.js>]

Description:
  Run the JavaScriptCore.framework jsc REPL.

  If no argument is provided, launch an interactive REPL session. If a
  filename is provided as the second argument, run that file with jsc.
EOM
jsc() {
  _jscbin="/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources/jsc"
  if [ -e "$_jscbin" ]; then
    _javascript_filename="$1"
    if [[ -z "$_javascript_filename" ]]; then
      "$_jscbin"
    else
      _debug printf "jsc() \$_javascript_filename: %s\n" "$_javascript_filename"
      "$_jscbin" "$_javascript_filename"
    fi
  else
    printf "JavaScriptCore.framework not found.\n"
  fi
}

# -------------------------------------------------------------- LaunchServices

desc launch_services <<EOM
Usage:
  $_ME launch_services cleanup

Description:
  Clean up LaunchServices to remove duplicates in the "Open With" menu.
EOM
launch_services() {
  _cmd_path="/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister"
  _action="$1"
  if [[ "$_action" == "cleanup" ]]; then
    "$_cmd_path" -kill -r -domain local -domain system -domain user && \
      killall Finder
  else
    _print_desc "locate"
  fi

}

# ---------------------------------------------------------------------- Locate

desc locate <<EOM
Usage:
  $_ME locate updatedb

Description:
  Update the locate database.

  NOTE: prefer using \`spotlight\` commands rather than \`locate\`.
EOM
locate() {
  _action="$1"
  if [[ "$_action" == "updatedb" ]]; then
    sudo /usr/libexec/locate.updatedb
  else
    _print_desc "locate"
  fi
}

# ----------------------------------------------------------------- Preferences

desc plistbuddy <<EOM
Usage:
  $_ME plistbuddy <PlistBuddy arguments> [<PlistBuddy options>]

Description:
  PlistBuddy alias, because sometimes \`defaults\` just doesnâ€™t cut it.
EOM
plistbuddy() {
  /usr/libexec/PlistBuddy "$@"
}

# ------------------------------------------------------------------ Quick Look

desc ql <<EOM
Usage:
  $_ME ql <item>

Description:
  Open items with Quick Look.
EOM
ql() {
  qlmanage -p "$*" > /dev/null 2>&1
}

# -------------------------------------------------------------------- Security

desc afk <<EOM
Usage:
  $_ME afk

Description:
  Lock the screen (when going AFK)
EOM
afk() {
  "/System/Library/CoreServices/Menu Extras/User.menu/Contents/Resources/CGSession" -suspend
}

# ----------------------------------------------------------------------- Sleep

desc sleep <<EOM
Usage:
  $_ME sleep

Description:
  Put the system to sleep immediately.
EOM
sleep() {
  pmset sleepnow
}

# ------------------------------------------------------------------- Spotlight

desc spotlight <<EOM
Usage:
  spotlight find      <filename>
  spotlight filename  <filename>
  spotlight content   <text>
  spotlight disable
  spotlight enable

Description:
  Spotlight searching and controls.
EOM
spotlight() {
  case "$1" in
    filename|find)
      shift
      mdfind "kMDItemDisplayName == '$*'wc"
      ;;
    content)
      shift
      mdfind -interpret "$*"
      ;;
    disable)
      sudo mdutil -a -i off
      ;;
    enable)
      sudo mdutil -a -i on
      ;;
    *)
      _print_desc "spotlight"
      ;;
  esac
}

desc sl <<EOM
Description:
  Spotlight searching and controls. This is an alias for the \`spotlight\`
  function. See \`help spotlight\` for usage information.
EOM
sl() {
  $_ME spotlight "$@"
}

# ----------------------------------------------------------------------- Trash

desc trash <<EOM
Usage:
$_ME trash ( empty [--secure] [--all] | open )

Subcommands:
  empty  Empty the trash.
  open   Open the trash folder in the finder.

Options:
  --secure  Use \`srm\` to securely delete trash contents.
  --all     Empty trashes on all connected volumes.
EOM
trash() {
  local _subcommand=
  local _secure=
  local _all=
  for arg in "${command_argv[@]:-}"; do
    case "$arg" in
      empty|open)
        _subcommand="$arg"
        ;;
      --secure)
        _secure=1
        ;;
      --all)
        _all=1
        ;;
      *)
        :
        ;;
    esac
  done
  if [[ "$_subcommand" = "open" ]];then
    open "$HOME/.Trash"
  elif [[ "$_subcommand" = "empty" ]]; then
    local _trash_command="rm -rfv"
    if [[ -n "$_secure" ]]; then
      _trash_command="srm -rfvm"
    fi

    sudo "$_trash_command" ~/.Trash/
    if [[ -n "$_all" ]]; then
      sudo "$_trash_command" /Volumes/*/.Trashes
    fi
  else
    _print_desc "trash"
  fi
}

# --------------------------------------------------------------------- Updates

desc update_apps <<EOM
Usage:
  $_ME update_apps

Description:
  Get and install updates from the App Store.
EOM
update_apps() {
  softwareupdate -i -a
}

###############################################################################
# Platform Check
###############################################################################

if [[ ! "$OSTYPE" =~ ^darwin ]]; then
  printf "osx-cli is only supported on OS X.\nExiting...\n"
  exit 0
fi

###############################################################################
# Run Program
###############################################################################

# Calling the _main function after everything has been defined.
_main

